package integration

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/google/go-github/v73/github"
	"github.com/wolfmagnate/daily_report/collector/domain"
	"golang.org/x/oauth2"
)

type GithubIntegrator interface {
	GetUserEvents(ctx context.Context, githubIntegration *domain.GithubIntegration, userID domain.UserID) ([]*domain.GithubActivity, bool, *oauth2.Token, string, error)
}

type githubIntegrator struct {
	conf *oauth2.Config
}

func NewGithubIntegrator() GithubIntegrator {
	return &githubIntegrator{
		conf: &oauth2.Config{
			ClientID:     os.Getenv("GITHUB_CLIENT_ID"),
			ClientSecret: os.Getenv("GITHUB_CLIENT_SECRET"),
			Endpoint: oauth2.Endpoint{
				TokenURL: "https://github.com/login/oauth/access_token",
			},
		},
	}
}

func (s *githubIntegrator) GetUserEvents(ctx context.Context, githubIntegration *domain.GithubIntegration, userID domain.UserID) ([]*domain.GithubActivity, bool, *oauth2.Token, string, error) {
	originalToken := githubIntegration.Token
	tokenSource := s.conf.TokenSource(ctx, originalToken)
	httpClient := oauth2.NewClient(ctx, tokenSource)
	githubClient := github.NewClient(httpClient)

	events, _, err := githubClient.Activity.ListEventsPerformedByUser(ctx, githubIntegration.GithubUsername, false, &github.ListOptions{
		Page:    1,
		PerPage: 100,
	})
	if err != nil {
		return nil, false, nil, "", fmt.Errorf("failed to get user events: %w", err)
	}

	// Check if token was refreshed
	newToken, err := tokenSource.Token()
	if err != nil {
		return nil, false, nil, "", fmt.Errorf("failed to retrieve token from token source: %w", err)
	}
	tokenUpdated := originalToken.AccessToken != newToken.AccessToken

	if len(events) == 0 {
		return nil, tokenUpdated, newToken, "", nil
	}

	latestEventID := events[0].GetID()

	filteredEvents := make([]*github.Event, 0)
	for _, event := range events {
		if event.GetID() == githubIntegration.LastProcessedEventID {
			break
		}
		filteredEvents = append(filteredEvents, event)
	}

	if len(filteredEvents) == 0 {
		return nil, tokenUpdated, newToken, latestEventID, nil
	}

	activities := make([]*domain.GithubActivity, 0, len(filteredEvents))
	for _, event := range filteredEvents {
		parsedPayload, err := event.ParsePayload()
		if err != nil {
			continue
		}

		payloadBytes, err := json.Marshal(parsedPayload)
		if err != nil {
			continue
		}

		var repoName, eventURL string
		if event.GetRepo() != nil {
			repoName = event.GetRepo().GetName()
		}

		switch p := parsedPayload.(type) {
		case *github.PullRequestEvent:
			if p.GetPullRequest() != nil {
				eventURL = p.GetPullRequest().GetHTMLURL()
			}
		case *github.IssuesEvent:
			if p.GetIssue() != nil {
				eventURL = p.GetIssue().GetHTMLURL()
			}
		case *github.IssueCommentEvent:
			if p.GetComment() != nil {
				eventURL = p.GetComment().GetHTMLURL()
			}
		}

		var createdAt time.Time
		if event.CreatedAt != nil {
			createdAt = event.GetCreatedAt().Time
		}

		activity, err := domain.NewGithubActivity(
			0, // ID will be generated by the database
			userID,
			event.GetID(),
			event.GetType(),
			eventURL,
			repoName,
			payloadBytes,
			createdAt.Unix(),
		)
		if err != nil {
			continue
		}
		activities = append(activities, activity)
	}
	return activities, tokenUpdated, newToken, latestEventID, nil
}
